<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Êï∞Â≠óÂçéÂÆπÈÅì - ÊâãÊú∫Áâà</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            touch-action: manipulation;
        }

        .container {
            width: 100%;
            max-width: 400px;
            text-align: center;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .game-info {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            color: white;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .info-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .puzzle-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 8px;
            aspect-ratio: 1;
            width: 100%;
        }

        .tile {
            background: linear-gradient(145deg, #667eea, #764ba2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .tile:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .empty {
            background: rgba(102, 126, 234, 0.2);
            border: 3px dashed rgba(255, 255, 255, 0.5);
            box-shadow: none;
        }

        .empty::after {
            content: "Á©∫";
            color: rgba(255, 255, 255, 0.5);
            font-size: 1rem;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            background: linear-gradient(145deg, #ff6b6b, #ee5a52);
            border: none;
            border-radius: 25px;
            color: white;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            flex: 1;
            max-width: 150px;
        }

        button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #newGame {
            background: linear-gradient(145deg, #4ecdc4, #44a08d);
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            transition: all 0.5s ease;
            z-index: 1000;
        }

        .message.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .message h2 {
            color: #333;
            margin-bottom: 10px;
        }

        .message p {
            color: #666;
            margin-bottom: 20px;
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }
            
            .tile {
                font-size: 1.5rem;
            }
            
            button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Êï∞Â≠óÂçéÂÆπÈÅì</h1>
        
        <div class="game-info">
            <div class="info-item">
                <div class="info-label">Ê≠•Êï∞</div>
                <div id="moveCount" class="info-value">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Êó∂Èó¥</div>
                <div id="timer" class="info-value">00:00</div>
            </div>
        </div>

        <div class="puzzle-container">
            <div class="puzzle-grid" id="puzzleGrid">
                <!-- ÊãºÂõæÂùóÂ∞ÜÈÄöËøáJavaScriptÂä®ÊÄÅÁîüÊàê -->
            </div>
        </div>

        <div class="controls">
            <button id="newGame">Êñ∞Ê∏∏Êàè</button>
            <button id="reset">ÈáçÁΩÆ</button>
        </div>
    </div>

    <div class="message" id="successMessage">
        <h2>üéâ ÊÅ≠ÂñúÂÆåÊàêÔºÅ</h2>
        <p id="completionStats"></p>
        <button onclick="hideMessage()">ÁªßÁª≠Ê∏∏Êàè</button>
    </div>

    <script>
        class SlidingPuzzle {
            constructor() {
                this.size = 4;
                this.tiles = [];
                this.emptyIndex = 15; // 4x4ÁΩëÊ†º‰∏≠ÊúÄÂêé‰∏Ä‰∏™‰ΩçÁΩÆÊòØÁ©∫Ê†º
                this.moveCount = 0;
                this.startTime = null;
                this.timerInterval = null;
                this.elapsedTime = 0;
                this.isSolved = false;
                
                this.init();
            }

            init() {
                this.createSolvedState();
                this.setupEventListeners();
                this.updateDisplay();
                this.startTimer();
            }

            // ÂàõÂª∫Â∑≤Ëß£ÂÜ≥Áä∂ÊÄÅÔºàÊúâÂ∫èÊéíÂàóÔºâ
            createSolvedState() {
                this.tiles = [];
                for (let i = 1; i <= this.size * this.size; i++) {
                    this.tiles.push(i);
                }
                this.tiles[this.tiles.length - 1] = 0; // ÊúÄÂêé‰∏Ä‰∏™‰ΩçÁΩÆÊòØÁ©∫Ê†º
                this.emptyIndex = this.tiles.length - 1;
            }

            // ÁîüÊàêÊúâËß£ÁöÑÊâì‰π±Áä∂ÊÄÅ
            shuffle() {
                // ÈÄöËøáÊ®°ÊãüÈöèÊú∫ÁßªÂä®Êù•Á°Æ‰øùÊúâËß£
                const moves = 1000; // Ë∂≥Â§üÁöÑÁßªÂä®Ê¨°Êï∞Á°Æ‰øùÂÖÖÂàÜÊâì‰π±
                const directions = [-1, 1, -this.size, this.size]; // Â∑¶„ÄÅÂè≥„ÄÅ‰∏ä„ÄÅ‰∏ã

                for (let i = 0; i < moves; i++) {
                    const possibleMoves = directions.filter(dir => {
                        const newIndex = this.emptyIndex + dir;
                        return this.isValidMove(newIndex);
                    });

                    if (possibleMoves.length > 0) {
                        const randomDir = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        this.swapTiles(this.emptyIndex, this.emptyIndex + randomDir);
                    }
                }

                this.moveCount = 0;
                this.elapsedTime = 0;
                this.isSolved = false;
                this.updateMoveCount();
                this.resetTimer();
            }

            isValidMove(index) {
                if (index < 0 || index >= this.size * this.size) return false;
                
                // Ê£ÄÊü•ÁßªÂä®ÊòØÂê¶Âú®Âêå‰∏Ä‰∏™Ë°å/Âàó
                const emptyRow = Math.floor(this.emptyIndex / this.size);
                const emptyCol = this.emptyIndex % this.size;
                const targetRow = Math.floor(index / this.size);
                const targetCol = index % this.size;

                return (emptyRow === targetRow && Math.abs(emptyCol - targetCol) === 1) ||
                       (emptyCol === targetCol && Math.abs(emptyRow - targetRow) === 1);
            }

            swapTiles(index1, index2) {
                [this.tiles[index1], this.tiles[index2]] = [this.tiles[index2], this.tiles[index1]];
                this.emptyIndex = this.tiles[index1] === 0 ? index1 : index2;
            }

            moveTile(index) {
                if (this.isSolved || !this.isValidMove(index)) return false;

                this.swapTiles(this.emptyIndex, index);
                this.moveCount++;
                this.updateMoveCount();

                if (this.checkSolution()) {
                    this.solve();
                }

                this.updateDisplay();
                return true;
            }

            checkSolution() {
                for (let i = 0; i < this.tiles.length - 1; i++) {
                    if (this.tiles[i] !== i + 1) return false;
                }
                return this.tiles[this.tiles.length - 1] === 0;
            }

            solve() {
                this.isSolved = true;
                clearInterval(this.timerInterval);
                this.showSuccessMessage();
            }

            updateDisplay() {
                const grid = document.getElementById('puzzleGrid');
                grid.innerHTML = '';

                this.tiles.forEach((tile, index) => {
                    const tileElement = document.createElement('div');
                    tileElement.className = tile === 0 ? 'tile empty' : 'tile';
                    
                    if (tile !== 0) {
                        tileElement.textContent = tile;
                        tileElement.onclick = () => this.moveTile(index);
                    }

                    grid.appendChild(tileElement);
                });
            }

            updateMoveCount() {
                document.getElementById('moveCount').textContent = this.moveCount;
            }

            startTimer() {
                this.startTime = Date.now() - this.elapsedTime;
                clearInterval(this.timerInterval);
                
                this.timerInterval = setInterval(() => {
                    if (!this.isSolved) {
                        this.elapsedTime = Date.now() - this.startTime;
                        this.updateTimer();
                    }
                }, 1000);
            }

            updateTimer() {
                const minutes = Math.floor(this.elapsedTime / 60000);
                const seconds = Math.floor((this.elapsedTime % 60000) / 1000);
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            resetTimer() {
                this.elapsedTime = 0;
                this.startTimer();
                this.updateTimer();
            }

            showSuccessMessage() {
                const message = document.getElementById('successMessage');
                const stats = document.getElementById('completionStats');
                
                const minutes = Math.floor(this.elapsedTime / 60000);
                const seconds = Math.floor((this.elapsedTime % 60000) / 1000);
                
                stats.textContent = `Áî®Êó∂: ${minutes}ÂàÜ${seconds}Áßí | Ê≠•Êï∞: ${this.moveCount}`;
                message.classList.add('show');
            }

            setupEventListeners() {
                document.getElementById('newGame').addEventListener('click', () => {
                    this.shuffle();
                    this.updateDisplay();
                });

                document.getElementById('reset').addEventListener('click', () => {
                    this.createSolvedState();
                    this.moveCount = 0;
                    this.elapsedTime = 0;
                    this.isSolved = false;
                    this.updateMoveCount();
                    this.resetTimer();
                    this.updateDisplay();
                });

                // Ê∑ªÂä†ÈîÆÁõòÊéßÂà∂ÔºàÊ°åÈù¢Á´ØÂ§áÁî®Ôºâ
                document.addEventListener('keydown', (e) => {
                    if (this.isSolved) return;

                    let targetIndex = -1;
                    switch(e.key) {
                        case 'ArrowUp': targetIndex = this.emptyIndex + this.size; break;
                        case 'ArrowDown': targetIndex = this.emptyIndex - this.size; break;
                        case 'ArrowLeft': targetIndex = this.emptyIndex + 1; break;
                        case 'ArrowRight': targetIndex = this.emptyIndex - 1; break;
                    }

                    if (targetIndex !== -1 && this.isValidMove(targetIndex)) {
                        this.moveTile(targetIndex);
                    }
                });
            }
        }

        function hideMessage() {
            document.getElementById('successMessage').classList.remove('show');
        }

        // È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñÊ∏∏Êàè
        document.addEventListener('DOMContentLoaded', () => {
            window.puzzleGame = new SlidingPuzzle();
            // ÂàùÂßãÊâì‰π±
            setTimeout(() => {
                window.puzzleGame.shuffle();
                window.puzzleGame.updateDisplay();
            }, 500);
        });
    </script>
</body>
</html>
